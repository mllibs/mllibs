var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"home.html","title":"Home","text":""},{"location":"home.html#about-mllibs","title":"About mllibs","text":"<p>Some key points about the library:</p> <ul> <li><code>mllibs</code> is a Machine Learning (ML) library which utilises natural language processing (NLP)</li> <li>Development of such helper modules are motivated by the fact that everyones understanding of coding &amp; subject matter (ML in this case) may be different </li> <li>Often we see people create <code>functions</code> and <code>classes</code> to simplify the process of code automation (which is good practice)</li> <li>Likewise, NLP based interpreters follow this trend as well, except, in this case our only inputs for activating certain code is <code>natural language</code></li> <li>Using python, we can interpret <code>natural language</code> in the form of <code>string</code> type data, using <code>natural langauge interpreters</code></li> <li><code>mllibs</code> aims to provide an automated way to do machine learning using natural language</li> </ul>"},{"location":"home.html#code-automation","title":"Code Automation","text":""},{"location":"home.html#types-of-approaches","title":"Types of Approaches","text":"<p>There are different ways we can automate code execution: - The first two (<code>function</code>,<code>class</code>) should be familiar, such approaches presume we have coding knowledge. - Another approach is to utilise <code>natural language</code> to automate code automation, this method doesn't require any coding knowledge. </p> <p>Info</p> FunctionClassNLP <p>Function based code automation should be very familiar to people who code, we define a function &amp; then simply call the function, entering any relevant input arguments which it requires, in this case <code>n</code></p> <pre><code>def fib_list(n):\n    result = []\n    a,b = 0,1\n    while a&lt;n:\n        result.append(a)\n        a,b = b, a + b\n    return result\n\nfib_list(5) \n</code></pre> <p>Another common approach to automate code is using a class based approach. Utilising <code>OOP</code> concepts we can initialise &amp; then call class <code>methods</code> in order to automate code:</p> <pre><code>class fib_list:\n\n    def __init__(self,n):\n        self.n = n\n\n    def get_list(self):\n        result = []\n        a,b = 0,1\n        while a&lt;self.n:\n            result.append(a)\n            a,b = b, a + b\n        return result\n\nfib = fib_list(5)\nfib.get_list()\n</code></pre> <p>Another approach, which <code>mllibs</code> uses in natural language based code automation:</p> <pre><code>input = 'calculate the fibonacci'\n         sequence for the value of 5'\n\nnlp_interpreter(input) \n</code></pre> <p>All these methods will give the following result:</p> <pre><code>[0, 1, 1, 2, 3]\n</code></pre>"},{"location":"home.html#library-components","title":"Library Components","text":"<p><code>mllibs</code> consists of two parts:</p> <p> modules associated with the interpreter</p> <ul> <li><code>nlpm</code> - groups together everything required for the interpreter module <code>nlpi</code></li> <li><code>nlpi</code> - main interpreter component module (requires <code>nlpm</code> instance)</li> <li><code>snlpi</code> - single request interpreter module (uses <code>nlpi</code>)</li> <li><code>mnlpi</code> - multiple request interpreter module (uses <code>nlpi</code>)</li> <li><code>interface</code> - interactive module (chat type)</li> </ul> <p> custom added modules, for mllibs these library are associated with machine learning topics</p> <p>You can check all the activations functions using <code>session.fl()</code> as shown in the sample notebooks in folder <code>examples</code></p>"},{"location":"home.html#module-component-structure","title":"Module Component Structure","text":"<p>Currently new modules can be added using a custom class <code>sample</code> and a configuration dictionary  <code>configure_sample</code></p> <pre><code># sample module class structure\nclass sample(nlpi):\n\n    # called in nlpm\n    def __init__(self,nlp_config):\n        self.name = 'sample'             # unique module name identifier (used in nlpm/nlpi)\n        self.nlp_config = nlp_config  # text based info related to module (used in nlpm/nlpi)\n\n    # called in nlpi\n    def sel(self,args:dict):\n\n        self.select = args['pred_task']\n        self.args = args\n\n        if(self.select == 'function'):\n            self.function(self.args)\n\n    # use standard or static methods\n\n    def function(self,args:dict):\n        pass\n\n    @staticmethod\n    def function(args:dict):\n        pass\n\n\ncorpus_sample = OrderedDict({\"function\":['task']}\ninfo_sample = {'function': {'module':'sample',\n                            'action':'action',\n                            'topic':'topic',\n                            'subtopic':'sub topic',\n                            'input_format':'input format for data',\n                            'output_format':'output format for data',\n                            'description':'write description'}}\n\n# configuration dictionary (passed in nlpm)\nconfigure_sample = {'corpus':corpus_sample,'info':info_sample}\n</code></pre>"},{"location":"home.html#creating-a-collection","title":"Creating a Collection","text":"<p><code>Modules</code> which we create need to be assembled together into a <code>collection</code>, there are two ways to do this: manually importing and grouping modules or using  <code>interface</code> class</p>"},{"location":"home.html#1-manually-importing-modules","title":"(1) Manually Importing Modules","text":"<p>First we need to combine all our module components together, this will link all passed modules together</p> <pre><code>collection = nlpm()\ncollection.load([loader(configure_loader),\n                 simple_eda(configure_eda),\n                 encoder(configure_nlpencoder),\n                 embedding(configure_nlpembed),\n                 cleantext(configure_nlptxtclean),\n                 sklinear(configure_sklinear),\n                 hf_pipeline(configure_hfpipe),\n                 eda_plot(configure_edaplt)])  \n</code></pre> <p>Then we need to train <code>interpreter</code> models</p> <pre><code>collection.train()\n</code></pre> <p>Lastly, pass the collection of modules (<code>nlpm</code> instance) to the interpreter <code>nlpi</code> </p> <pre><code>session = nlpi(collection)\n</code></pre> <p>class <code>nlpi</code> can be used with method <code>exec</code> for user input interpretation</p> <pre><code>session.exec('create a scatterplot using data with x dimension1 y dimension2')\n</code></pre>"},{"location":"home.html#2-import-default-libraries","title":"(2) Import Default Libraries","text":"<p>The faster way, includes all loaded modules and groups them together for us:</p> <pre><code>from mllibs.interface import interface\nsession = interface()\n</code></pre>"},{"location":"home.html#how-to-contibute","title":"How to Contibute","text":"<p>Want to add your own project to our collection? We welcome all contributions! Here's how you can get started:</p> <ol> <li>Fork the repository</li> <li>Create a new branch for your changes</li> <li>Make your changes and commit them</li> <li>Submit a pull request</li> </ol>"},{"location":"install.html","title":"Installation","text":""},{"location":"install.html#installation","title":"Installation","text":""},{"location":"mlproject.html","title":"Your Project","text":"<p>Abstract</p> <p>In this sections you'll find the associated <code>mllibs</code> modules that correspond to different stages of a machine learning project</p>"},{"location":"mlproject.html#typical-steps-in-a-machine-learning-project","title":"Typical Steps in a Machine Learning Project:","text":"<p>Let's go through the different states of a machine learning project!</p>"},{"location":"mlproject.html#1-problem-definition","title":"1. Problem Definition","text":"<p>In this phase, we define the problem that we want to solve &amp; determine the goals of the project</p>"},{"location":"mlproject.html#2-data-collection","title":"2. Data Collection","text":"<p>During this phase of the project, we gather the relevant data that will be used to train &amp; test the model</p>"},{"location":"mlproject.html#3-data-preprocessing","title":"3. Data Preprocessing","text":"<p>During this phase, we conduct various data preprocessing procedures that will make it suitable for data analysis</p>"},{"location":"mlproject.html#4-data-exploration","title":"4. Data Exploration","text":"<p>During this phase of the project, we explore our dataset using various statistical and visualisation analysis techniques in order to gain some insight into our data</p>"},{"location":"mlproject.html#5-feature-engineering","title":"5. Feature Engineering","text":"<p>During this phase, we select relevant features that will be used as input into our model or create some additional features in the process</p>"},{"location":"mlproject.html#6-model-selection","title":"6. Model Selection","text":"<p>During this phase of the project, we select the relevant machine learning models that will be used in the project</p>"},{"location":"mlproject.html#7-model-training","title":"7. Model Training","text":"<p>During this phase of the project, we train the model on the data that we prepared</p>"},{"location":"mlproject.html#8-model-evaluation","title":"8. Model Evaluation","text":"<p>During this phase, we evaluate the performance of the trained model using the desired evaluation metrics</p>"},{"location":"mlproject.html#9-hyperparameter-optimisation","title":"9. Hyperparameter Optimisation","text":"<p>During this phase of the project, we optimise the parameters of the model in order to improve the model perform</p>"},{"location":"mlproject.html#10-deployment","title":"10. Deployment","text":"<p>The final phase of the project involves saving the model for use on new data</p>"},{"location":"documentation/nlpi.html","title":"nlpi","text":""},{"location":"documentation/nlpi.html#nlpi-class","title":"nlpi class","text":""},{"location":"documentation/nlpm.html","title":"nlpm","text":""},{"location":"documentation/nlpm.html#nlpm-class","title":"nlpm class","text":""},{"location":"documentation/eda/meda_scplot.html","title":"eda_scplot","text":""},{"location":"documentation/eda/meda_scplot.html#module-group","title":"Module Group","text":"<p><code>src/eda</code><sup>1</sup></p>"},{"location":"documentation/eda/meda_scplot.html#project-stage-id","title":"Project Stage ID","text":"<p>4<sup>2</sup></p>"},{"location":"documentation/eda/meda_scplot.html#purpose","title":"Purpose","text":"<p>The purpose of this module is to provide the user with the ability to visualise each numerical columns in a pandas dataframe in a two dimensional figure relative to other numerical columns, the module revolves around the utilisation of seaborn</p>"},{"location":"documentation/eda/meda_scplot.html#location","title":"Location","text":"<p>Here are the locations of the relevant files associated with the module</p> module information: <p><code>/corpus/meda_scplot.json</code><sup>3</sup></p> module activation functions: <p><code>/src/eda/meda_scplot.py</code><sup>4</sup></p>"},{"location":"documentation/eda/meda_scplot.html#requirements","title":"Requirements","text":"<p>Module import information</p> <pre><code>from mllibs.nlpi import nlpi\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport math\nfrom collections import OrderedDict\nimport warnings; warnings.filterwarnings('ignore')\nfrom mllibs.nlpm import parse_json\nimport pkg_resources\nimport json\n</code></pre>"},{"location":"documentation/eda/meda_scplot.html#selection","title":"Selection","text":"<p>Activation functions need to be assigned a unique label. Here's the process of <code>label</code> &amp; activation function selection </p> <pre><code>def sel(self,args:dict):\n\n    select = args['pred_task']\n\n    if(select == 'col_kde'):\n        self.eda_colplot_kde(args)\n    elif(select == 'col_box'):\n        self.eda_colplot_box(args)\n    elif(select == 'col_scatter'):\n        self.eda_colplot_scatter(args)\n</code></pre>"},{"location":"documentation/eda/meda_scplot.html#activation-functions","title":"Activation Functions","text":"<p>Here you will find the relevant activation functions available in class <code>meda_scplot</code></p>"},{"location":"documentation/eda/meda_scplot.html#col_kde","title":"<code>col_kde</code>","text":""},{"location":"documentation/eda/meda_scplot.html#description","title":"description:","text":"<p>visualise/plot column feature kernel density estimation plot</p>"},{"location":"documentation/eda/meda_scplot.html#code","title":"code:","text":"<pre><code>def eda_colplot_kde(self,args:dict):\n\n    # get numeric column names only\n    num,_ = self.split_types(args['data'])\n\n    if(args['x'] is not None):\n        xloc = args['data'][args['x']]\n    else:\n        xloc = None\n\n    if(args['hue'] is not None):\n        hueloc = args['data'][args['hue']]\n        if(type(nlpi.pp['stheme']) is str):\n            palette = nlpi.pp['stheme']\n        else:\n            palette = palette_rgb[:len(hueloc.value_counts())]\n\n    else:\n        hueloc = None\n        palette = palette_rgb\n\n    columns = list(num.columns)  \n    n_cols = 3\n    n_rows = math.ceil(len(columns)/n_cols)\n\n    fig, ax = plt.subplots(n_rows, n_cols, figsize=(16, n_rows*5))\n    ax = ax.flatten()\n\n    for i, column in enumerate(columns):\n        plot_axes = [ax[i]]\n\n        sns.set_style(\"whitegrid\", {\n        'grid.linestyle': '--'})\n\n        sns.kdeplot(data=args['data'],\n                    x=column,\n                    hue=hueloc,\n                    fill=nlpi.pp['fill'],\n                    alpha= nlpi.pp['alpha'],\n                    linewidth=nlpi.pp['mew'],\n                    edgecolor=nlpi.pp['mec'],\n                    ax=ax[i],\n                    common_norm=False,\n                    palette=palette\n                     )\n\n        # titles\n        ax[i].set_title(f'{column} distribution');\n        ax[i].set_xlabel(None)\n\n    for i in range(i+1, len(ax)):\n        ax[i].axis('off')\n\n    plt.tight_layout()\n</code></pre>"},{"location":"documentation/eda/meda_scplot.html#col_box","title":"<code>col_box</code>","text":""},{"location":"documentation/eda/meda_scplot.html#description_1","title":"description:","text":"<p>visualise/plot column feature boxplot</p>"},{"location":"documentation/eda/meda_scplot.html#code_1","title":"code:","text":"<pre><code>def eda_colplot_box(self,args:dict):\n\n# split data into numeric &amp; non numeric\nnum,cat = self.split_types(args['data'])\n\ncolumns = list(num.columns)  \nn_cols = 3\nn_rows = math.ceil(len(columns)/n_cols)\n\nif(args['x'] is not None):\n    xloc = args['data'][args['x']]\nelse:\n    xloc = None\n\nif(args['x'] is not None):\n    xloc = args['data'][args['x']]\nelse:\n    xloc = None\n\nif(args['hue'] is not None):\n    hueloc = args['data'][args['hue']]\n    if(type(nlpi.pp['stheme']) is str):\n        palette = nlpi.pp['stheme']\n    else:\n        palette = palette_rgb[:len(hueloc.value_counts())]\n\nelse:\n    hueloc = None\n    palette = palette_rgb\n\nfig, ax = plt.subplots(n_rows, n_cols, figsize=(16, n_rows*5))\nsns.despine(fig, left=True, bottom=True)\nax = ax.flatten()\n\nfor i, column in enumerate(columns):\n    plot_axes = [ax[i]]\n\n    sns.set_style(\"whitegrid\", {\n    'grid.linestyle': '--'})\n\n\n    if(args['bw'] is None):\n        bw = 0.8\n    else:\n        bw = eval(args['bw'])\n\n    sns.boxplot(\n        y=args['data'][column],\n        x=xloc,\n        hue=hueloc,\n        width=bw,\n        ax=ax[i],\n        palette=palette\n    )\n\n    # titles\n    ax[i].set_title(f'{column} distribution');\n    ax[i].set_xlabel(None)\n\n\nfor i in range(i+1, len(ax)):\n    ax[i].axis('off')\n\nplt.tight_layout()\n</code></pre>"},{"location":"documentation/eda/meda_scplot.html#col_scatter","title":"<code>col_scatter</code>","text":""},{"location":"documentation/eda/meda_scplot.html#description_2","title":"description:","text":"<p>visualise/plot column feature scatterplot</p>"},{"location":"documentation/eda/meda_scplot.html#code_2","title":"code:","text":"<pre><code>    def eda_colplot_scatter(self,args:dict):\n\n        # split data into numeric &amp; non numeric\n        num,_ = self.split_types(args['data'])\n\n        columns = list(num.columns)  \n        n_cols = 3\n        n_rows = math.ceil(len(columns)/n_cols)\n\n        if(args['x'] is not None):\n            xloc = args['data'][args['x']]\n        else:\n            xloc = None\n\n        if(args['hue'] is not None):\n            hueloc = args['data'][args['hue']]\n            if(type(nlpi.pp['stheme']) is str):\n                palette = nlpi.pp['stheme']\n            else:\n                palette = palette_rgb[:len(hueloc.value_counts())]\n\n        else:\n            hueloc = None\n            palette = palette_rgb\n\n        fig, ax = plt.subplots(n_rows, n_cols, figsize=(16, n_rows*5))\n        sns.despine(fig, left=True, bottom=True)\n        ax = ax.flatten()\n\n        for i, column in enumerate(columns):\n            plot_axes = [ax[i]]\n\n            sns.set_style(\"whitegrid\", {\n            'grid.linestyle': '--'})\n\n            sns.scatterplot(\n                y=args['data'][column],\n                x=xloc,\n                hue=hueloc,\n                alpha= nlpi.pp['alpha'],\n                linewidth=nlpi.pp['mew'],\n                edgecolor=nlpi.pp['mec'],\n                s = nlpi.pp['s'],\n                ax=ax[i],\n                palette=palette,\n            )\n\n            # titles\n            ax[i].set_title(f'{column} distribution');\n            ax[i].set_xlabel(None)\n\n\n        for i in range(i+1, len(ax)):\n            ax[i].axis('off')\n\n        plt.tight_layout()\n        plt.show()\n</code></pre> <ol> <li> <p>Reference to the sub folder in <code>src</code> \u21a9</p> </li> <li> <p>Reference to the machine learning project phase identification defined here \u21a9</p> </li> <li> <p>location | github \u21a9</p> </li> <li> <p>location | github \u21a9</p> </li> </ol>"},{"location":"documentation/eda/meda_simple.html","title":"eda_simple","text":""},{"location":"documentation/eda/meda_simple.html#module-group","title":"Module Group","text":"<p><code>src/eda</code><sup>1</sup></p>"},{"location":"documentation/eda/meda_simple.html#project-stage-id","title":"Project Stage ID","text":"<p>4<sup>2</sup></p>"},{"location":"documentation/eda/meda_simple.html#purpose","title":"Purpose","text":"<p>The purpose of this module is to provide the simple exploratory data analysis operations using <code>pandas</code></p>"},{"location":"documentation/eda/meda_simple.html#location","title":"Location","text":"<p>Here are the locations of the relevant files associated with the module</p> module information: <p><code>/corpus/meda_simple.json</code><sup>3</sup></p> module activation functions: <p><code>/src/eda/meda_simple.py</code><sup>4</sup></p>"},{"location":"documentation/eda/meda_simple.html#requirements","title":"Requirements","text":"<p>Module import information</p> <pre><code>import numpy as np\nimport pandas as pd\nfrom collections import OrderedDict\nfrom mllibs.nlpi import nlpi\nfrom mllibs.nlpm import parse_json\nimport pkg_resources\nimport json\n</code></pre>"},{"location":"documentation/eda/meda_simple.html#selection","title":"Selection","text":"<p>Activation functions need to be assigned a unique label. Here's the process of <code>label</code> &amp; activation function selection </p> <pre><code>def sel(self,args:dict):\n\n    # activation function class name\n    select = args['pred_task'] \n\n    # activate relevant function \n    if(select == 'show_info'):\n        self.show_info(args)\n\n    if(select == 'show_missing'):\n        self.show_missing(args)\n\n    if(select == 'show_stats'):\n        self.show_statistics(args)\n\n    if(select == 'show_dtypes'):\n        self.show_dtypes(args)\n\n    if(select == 'show_corr'):\n        self.show_correlation(args)\n</code></pre>"},{"location":"documentation/eda/meda_simple.html#activation-functions","title":"Activation Functions","text":"<p>Here you will find the relevant activation functions available in class <code>meda_simple</code></p>"},{"location":"documentation/eda/meda_simple.html#show_info","title":"<code>show_info</code>description:code:","text":"<p>The <code>pandas.DataFrame.info()</code> method is used to print a concise summary of a pandas DataFrame. It provides information such as the number of rows and columns, the data types of each column, the memory usage, and the number of non-null values in each column. This method is useful for quickly understanding the structure and content of a DataFrame, especially when working with large datasets. Additionally, it can help identify missing or null values that may need to be addressed in data cleaning or preprocessing.</p> <pre><code>@staticmethod\ndef show_info(args:dict):\n    print(args['data'].info())\n</code></pre>"},{"location":"documentation/eda/meda_simple.html#show_missing","title":"<code>show_missing</code>description:code:","text":"<p>The <code>pandas.DataFrame.info()</code> method is used to print a concise summary of a pandas DataFrame. It provides information such as the number of rows and columns, the data types of each column, the memory usage, and the number of non-null values in each column. This method is useful for quickly understanding the structure and content of a DataFrame, especially when working with large datasets. Additionally, it can help identify missing or null values that may need to be addressed in data cleaning or preprocessing.</p> <pre><code>@staticmethod\ndef show_missing(args:dict):\n    print(args['data'].isna().sum(axis=0))\n</code></pre>"},{"location":"documentation/eda/meda_simple.html#show_stats","title":"<code>show_stats</code>description:code:","text":"<p><code>pandas.DataFrame.describe()</code> is a method that provides a summary of the statistical properties of each column in a DataFrame. By default, it calculates the count, mean, standard deviation, minimum, 25th percentile, median (50th percentile), 75th percentile, and maximum for each numeric column. </p> <pre><code>@staticmethod\ndef show_statistics(args:dict):\n    display(args['data'].describe())\n</code></pre>"},{"location":"documentation/eda/meda_simple.html#show_dtypes","title":"<code>show_dtypes</code>description:code:","text":"<p><code>pandas.DataFrame.dtypes</code> is an attribute of a pandas DataFrame that returns the data types of each column in the DataFrame. This attribute is useful for understanding the data types of each column and can be used to convert columns to different data types if necessary.</p> <pre><code>@staticmethod\ndef show_dtypes(args:dict):\n    print(args['data'].dtypes)\n</code></pre>"},{"location":"documentation/eda/meda_simple.html#show_corr","title":"<code>show_corr</code>description:code:","text":"<p><code>pandas.DataFrame.corr()</code> is a method that calculates the correlation between columns in a DataFrame. Correlation is a statistical measure that indicates the degree to which two variables are related</p> <pre><code>@staticmethod\ndef show_correlation(args:dict):\n    corr_mat = pd.DataFrame(np.round(args['data'].corr(),2),\n                         index = list(args['data'].columns),\n                         columns = list(args['data'].columns))\n    corr_mat = corr_mat.dropna(how='all',axis=0)\n    corr_mat = corr_mat.dropna(how='all',axis=1)\n    display(corr_mat)\n</code></pre> <ol> <li> <p>Reference to the sub folder in <code>src</code> \u21a9</p> </li> <li> <p>Reference to the machine learning project phase identification defined here \u21a9</p> </li> <li> <p>location | github \u21a9</p> </li> <li> <p>location | github \u21a9</p> </li> </ol>"},{"location":"documentation/eda/meda_splot.html","title":"eda_splot","text":""},{"location":"documentation/eda/meda_splot.html#module-group","title":"Module Group","text":"<p><code>src/eda</code><sup>1</sup></p>"},{"location":"documentation/eda/meda_splot.html#project-stage-id","title":"Project Stage ID","text":"<p>4<sup>2</sup></p>"},{"location":"documentation/eda/meda_splot.html#purpose","title":"Purpose","text":"<p>The purpose of this module is to provide the user with the ability to utilise the basic visualisation tools provided in the library seaborn</p>"},{"location":"documentation/eda/meda_splot.html#location","title":"Location","text":"<p>Here are the locations of the relevant files associated with the module</p> module information: <p><code>/corpus/meda_splot.json</code><sup>3</sup></p> module activation functions: <p><code>/src/eda/meda_splot.py</code><sup>4</sup></p>"},{"location":"documentation/eda/meda_splot.html#requirements","title":"Requirements","text":"<p>Module import information</p> <pre><code>from mllibs.nlpi import nlpi\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom collections import OrderedDict\nimport warnings; warnings.filterwarnings('ignore')\nfrom mllibs.nlpm import parse_json\nimport pkg_resources\nimport json\n</code></pre>"},{"location":"documentation/eda/meda_splot.html#selection","title":"Selection","text":"<p>Activation functions need to be assigned a unique label. Here's the process of <code>label</code> &amp; activation function selection </p> <pre><code>def sel(self,args:dict):\n\n    select = args['pred_task']\n    self.data_name = args['data_name']\n\n    ''' \n\n    ADD EXTRA COLUMNS TO DATA \n\n    model_prediction | splits_col\n\n\n    '''\n    # split columns (tts,kfold,skfold) \n    if(len(nlpi.data[self.data_name[0]]['splits_col']) != 0):\n\n        split_dict = nlpi.data[self.data_name[0]]['splits_col']\n        extra_columns = pd.concat(split_dict,axis=1)\n        args['data'] = pd.concat([args['data'],extra_columns],axis=1)\n\n    # model predictions\n    if(len(nlpi.data[self.data_name[0]]['model_prediction']) != 0):\n\n        prediction_dict = nlpi.data[self.data_name[0]]['model_prediction']\n        extra_columns = pd.concat(prediction_dict,axis=1)\n        extra_columns.columns = extra_columns.columns.map('_'.join)\n        args['data'] = pd.concat([args['data'],extra_columns],axis=1)\n\n\n    ''' \n\n    Activatation Function\n\n    '''\n\n    if(select == 'sscatterplot'):\n        self.seaborn_scatterplot(args)\n    elif(select =='srelplot'):\n        self.seaborn_relplot(args)\n    elif(select == 'sboxplot'):\n        self.seaborn_boxplot(args)\n    elif(select == 'sresidplot'):\n        self.seaborn_residplot(args)\n    elif(select == 'sviolinplot'):\n        self.seaborn_violinplot(args)\n    elif(select == 'shistplot'):\n        self.seaborn_histplot(args)\n    elif(select == 'skdeplot'):\n        self.seaborn_kdeplot(args)\n    elif(select == 'slmplot'):\n        self.seaborn_lmplot(args)\n    elif(select == 'spairplot'):\n        self.seaborn_pairplot(args)\n    elif(select == 'slineplot'):\n        self.seaborn_lineplot(args)\n    elif(select == 'scorrplot'):\n        self.seaborn_heatmap(args)\n</code></pre>"},{"location":"documentation/eda/meda_splot.html#activation-functions","title":"Activation Functions","text":"<p>Here you will find the relevant activation functions available in class <code>meda_splot</code></p>"},{"location":"documentation/eda/meda_splot.html#sscatterplot","title":"<code>sscatterplot</code>description:code:","text":"<p>A Seaborn scatterplot is a type of plot used to visualize the relationship between two variables in a dataset. It is created using the seaborn library in Python and is often used to identify patterns and trends in the data.</p> <p>The plot shows a scatterplot of the data points, with each point representing a single observation. The x and y axes show the values of the two variables being plotted, and the plot can be customized to show additional information, such as a regression line or confidence intervals.</p> <p>The Seaborn scatterplot is a useful tool for exploring and visualizing relationships in your data, and can help you to identify any outliers or unusual observations.</p> <pre><code>@staticmethod\ndef seaborn_scatterplot(args:dict):\n\n    if(args['hue'] is not None):\n\n        hueloc = args['data'][args['hue']]\n        if(type(nlpi.pp['stheme']) is str):\n            palette = nlpi.pp['stheme']\n        else:\n            palette = palette_rgb[:len(hueloc.value_counts())]\n\n    else:\n        hueloc = None\n        palette = palette_rgb\n\n    sns.set_style(\"whitegrid\", {\n        \"ytick.major.size\": 0.1,\n        \"ytick.minor.size\": 0.05,\n        'grid.linestyle': '--'\n    })\n\n    sns.scatterplot(x=args['x'], \n                    y=args['y'],\n                    hue=args['hue'],\n                    alpha = nlpi.pp['alpha'],\n                    linewidth=nlpi.pp['mew'],\n                    edgecolor=nlpi.pp['mec'],\n                    s = nlpi.pp['s'],\n                    data=args['data'],\n                    palette=palette)\n\n    sns.despine(left=True, bottom=True)\n    plt.show()\n    nlpi.resetpp()\n</code></pre>"},{"location":"documentation/eda/meda_splot.html#srelplot","title":"<code>srelplot</code>description:code:","text":"<p>A Seaborn relplot is a type of plot used to visualize the relationship between two variables in a dataset. It is created using the seaborn library in Python and is often used to identify patterns and trends in the data.</p> <p>The plot shows a scatterplot of the data points, with each point representing a single observation. The x and y axes show the values of the two variables being plotted, and the plot can be customized to show additional information, such as a regression line or confidence intervals.</p> <p>The relplot can also be used to group the data by a categorical variable, creating separate plots for each group. This allows you to compare the relationship between the variables across different groups within the dataset.</p> <p>Overall, the Seaborn relplot is a powerful tool for exploring and visualizing relationships in your data.</p> <pre><code>@staticmethod\ndef seaborn_relplot(args:dict):\n\n    if(args['hue'] is not None):\n        hueloc = args['data'][args['hue']]\n        if(type(nlpi.pp['stheme']) is str):\n            palette = nlpi.pp['stheme']\n        else:\n            palette = palette_rgb[:len(hueloc.value_counts())]\n\n    else:\n        hueloc = None\n        palette = palette_rgb           \n\n    sns.set_style(\"whitegrid\", {\n        \"ytick.major.size\": 0.1,\n        \"ytick.minor.size\": 0.05,\n        'grid.linestyle': '--'\n    })\n\n    sns.relplot(x=args['x'], \n                y=args['y'],\n                col=args['col'],\n                row=args['row'],\n                hue=args['hue'], \n                col_wrap=args['col_wrap'],\n                kind=args['kind'],\n                palette=palette,\n                alpha= nlpi.pp['alpha'],\n                s = nlpi.pp['s'],\n                linewidth=nlpi.pp['mew'],\n                edgecolor=nlpi.pp['mec'],\n                data=args['data'])\n\n    sns.despine(left=True, bottom=True)\n    plt.show()\n    nlpi.resetpp()\n</code></pre>"},{"location":"documentation/eda/meda_splot.html#sboxplot","title":"<code>sboxplot</code>description:code:","text":"<p>A Seaborn boxplot is a type of plot used to visualize the distribution of a dataset. It is created using the seaborn library in Python and is often used to identify outliers and compare the distribution of different groups or categories within a dataset.</p> <p>The plot shows a box that represents the interquartile range (IQR) of the data, which is the range between the 25th and 75th percentiles. The line inside the box represents the median value, while the whiskers extend to show the range of the data, excluding any outliers. Outliers are plotted as individual points beyond the whiskers.</p> <p>The boxplot can be customized to show additional information, such as the mean value or confidence intervals, and can be grouped by a categorical variable to compare the distribution of different groups within the dataset. By examining the boxplot, you can identify any skewness or asymmetry in the distribution, as well as any extreme values that may need to be addressed.</p> <pre><code>@staticmethod\ndef seaborn_boxplot(args:dict):\n\n    if(args['hue'] is not None):\n        hueloc = args['data'][args['hue']]\n        if(type(nlpi.pp['stheme']) is str):\n            palette = nlpi.pp['stheme']\n        else:\n            palette = palette_rgb[:len(hueloc.value_counts())]\n\n    else:\n        hueloc = None\n        palette = palette_rgb\n\n    sns.set_style(\"whitegrid\", {\n        \"ytick.major.size\": 0.1,\n        \"ytick.minor.size\": 0.05,\n        'grid.linestyle': '--'\n    })\n\n    if(args['bw'] is None):\n        bw = 0.8\n    else:\n        bw = eval(args['bw'])\n\n    sns.boxplot(x=args['x'], \n                y=args['y'],\n                hue=args['hue'],\n                width=bw,\n                palette=palette,\n                data=args['data'])\n\n    sns.despine(left=True, bottom=True)\n    plt.show()\n</code></pre>"},{"location":"documentation/eda/meda_splot.html#sresidplot","title":"<code>sresidplot</code>description:code:","text":"<p>A Seaborn residual plot is a type of plot used to visualize the residuals (the difference between the predicted values and the actual values) of a regression model. It is created using the seaborn library in Python and is often used to check whether the assumptions of linear regression are met, such as linearity, homoscedasticity, and normality. </p> <p>The plot shows the distribution of the residuals on the y-axis and the predicted values on the x-axis. The residuals are plotted as points with a horizontal line at zero to show the expected value of the residuals if the model is accurate. The plot also includes a fitted line that represents the regression line of the model.</p> <p>By examining the residual plot, you can identify patterns or trends in the residuals that may indicate that the model is not appropriate for the data or that there are outliers or influential points that need to be addressed.</p> <pre><code>@staticmethod\ndef seaborn_residplot(args:dict):\n    sns.residplot(x=args['x'], \n                  y=args['y'],\n                  color=nlpi.pp['stheme'][1],\n                  data=args['data'])\n\n    sns.despine(left=True, bottom=True)\n    plt.show()\n</code></pre>"},{"location":"documentation/eda/meda_splot.html#sviolinplot","title":"<code>sviolinplot</code>description:code:","text":"<p>A Seaborn violinplot is a type of plot used to visualize the distribution of a single variable in a dataset. It is created using the seaborn library in Python and is often used to compare the distribution of the variable across different categories or groups.</p> <p>The plot shows a \"violin\" shape, which represents the distribution of the data. The width of the violin at any point represents the density of observations at that point, with wider parts indicating more observations. The plot can also show additional information, such as the median and quartiles of the data.</p> <p>The Seaborn violinplot is a useful tool for exploring and visualizing the distribution of your data, and can help you to identify any differences or similarities between groups or categories.</p> <pre><code>@staticmethod\ndef seaborn_violinplot(args:dict):\n\n    if(args['hue'] is not None):\n        hueloc = args['data'][args['hue']]\n        if(type(nlpi.pp['stheme']) is str):\n            palette = nlpi.pp['stheme']\n        else:\n            palette = palette_rgb[:len(hueloc.value_counts())]\n\n    else:\n        hueloc = None\n        palette = palette_rgb\n\n    sns.set_style(\"whitegrid\", {\n        \"ytick.major.size\": 0.1,\n        \"ytick.minor.size\": 0.05,\n        'grid.linestyle': '--'\n    })\n\n    sns.violinplot(x=args['x'], \n                   y=args['y'],\n                   hue=args['hue'],\n                   palette=palette,\n                   data=args['data'])\n\n    sns.despine(left=True, bottom=True)\n    plt.show()\n    nlpi.resetpp()\n</code></pre>"},{"location":"documentation/eda/meda_splot.html#shistplot","title":"<code>shistplot</code>description:code:","text":"<p>A Seaborn histplot is a type of plot used to visualize the distribution of a single variable in a dataset. It is created using the seaborn library in Python and is often used to explore the shape of the distribution, as well as any outliers or gaps in the data.</p> <p>The plot shows a histogram, which is a bar chart that represents the frequency of values in the dataset. The x-axis represents the range of values, and the y-axis represents the frequency of those values. The bars are typically grouped into bins, which represent a range of values.</p> <p>The Seaborn histplot can also show additional information, such as the density of the data or a kernel density estimate. It is a useful tool for exploring and visualizing the distribution of your data, and can help you to identify any patterns or trends in the data.</p> <pre><code>@staticmethod\ndef seaborn_histplot(args:dict):\n\n    if(args['hue'] is not None):\n        hueloc = args['data'][args['hue']]\n        if(type(nlpi.pp['stheme']) is str):\n            palette = nlpi.pp['stheme']\n        else:\n            palette = palette_rgb[:len(hueloc.value_counts())]\n\n    else:\n        hueloc = None\n        palette = palette_rgb\n\n    sns.set_style(\"whitegrid\", {\n        \"ytick.major.size\": 0.1,\n        \"ytick.minor.size\": 0.05,\n        'grid.linestyle': '--'\n    })\n\n    # bar width\n    if(args['bw'] is None):\n        bw = 'auto'\n    else:\n        bw = eval(args['bw'])\n\n    sns.histplot(x=args['x'], \n                 y=args['y'],\n                 hue = args['hue'],\n                 bins = bw,\n                 palette = palette,\n                 data=args['data'])\n\n    sns.despine(left=True, bottom=True)\n    plt.show()\n    nlpi.resetpp()\n</code></pre>"},{"location":"documentation/eda/meda_splot.html#skdeplot","title":"<code>skdeplot</code>description:code:","text":"<p>A Seaborn kdeplot is a type of plot used to visualize the distribution of a single variable in a dataset, similar to a histplot. However, instead of using bars to represent the frequency of values, it uses a kernel density estimate (KDE) to create a smooth curve that represents the distribution of the data.</p> <p>The plot shows the density of the data, with higher peaks indicating where the data is more concentrated. The x-axis represents the range of values, and the y-axis represents the density of those values.</p> <p>A Seaborn kdeplot can also show additional information, such as a rug plot that indicates the location of each individual data point along the x-axis. It is a useful tool for exploring and visualizing the distribution of your data, and can help you to identify any patterns or trends in the data.</p> <pre><code>@staticmethod\ndef seaborn_kdeplot(args:dict):\n\n    if(args['hue'] is not None):\n        hueloc = args['data'][args['hue']]\n        if(type(nlpi.pp['stheme']) is str):\n            palette = nlpi.pp['stheme']\n        else:\n            palette = palette_rgb[:len(hueloc.value_counts())]\n\n    else:\n        hueloc = None\n        palette = palette_rgb\n\n    sns.set_style(\"whitegrid\", {\n        \"ytick.major.size\": 0.1,\n        \"ytick.minor.size\": 0.05,\n        'grid.linestyle': '--'\n    })            \n\n    sns.kdeplot(x=args['x'],\n                y=args['y'],\n                palette=palette,\n                fill=nlpi.pp['fill'],\n                data = args['data'],\n                hue = args['hue'])\n\n    sns.despine(left=True, bottom=True)\n    plt.show()\n    nlpi.resetpp()\n</code></pre>"},{"location":"documentation/eda/meda_splot.html#slmplot","title":"<code>slmplot</code>description:code:","text":"<p>A Seaborn lmplot is a type of plot used to visualize the relationship between two variables in a dataset, typically using a scatter plot with a regression line. It can be used to explore the correlation between two variables and to identify any patterns or trends in the data.</p> <p>The lmplot function in Seaborn allows you to specify various parameters, such as the x and y variables, the data source, and the type of regression model to use. It also allows you to add additional information to the plot, such as confidence intervals and hue variables that can be used to group the data by a categorical variable.</p> <p>Overall, Seaborn lmplots are a useful tool for exploring and visualizing the relationship between two variables in a dataset, and can help you to gain insights into the underlying patterns and trends in your data.</p> <pre><code>@staticmethod\ndef seaborn_lmplot(args:dict):\n\n    if(args['hue'] is not None):\n        hueloc = args['data'][args['hue']]\n        if(type(nlpi.pp['stheme']) is str):\n            palette = nlpi.pp['stheme']\n        else:\n            palette = palette_rgb[:len(hueloc.value_counts())]\n\n    else:\n        hueloc = None\n        palette = palette_rgb\n\n    sns.set_style(\"whitegrid\", {\n        \"ytick.major.size\": 0.1,\n        \"ytick.minor.size\": 0.05,\n        'grid.linestyle': '--'})\n\n    sns.lmplot(x=args['x'], \n               y=args['y'],\n               hue=args['hue'],\n               col=args['col'],\n               row=args['row'],\n               data=args['data'],\n               palette=palette)\n\n    sns.despine(left=True, bottom=True)\n    plt.show()\n</code></pre>"},{"location":"documentation/eda/meda_splot.html#spairplot","title":"<code>spairplot</code>description:code:","text":"<p>A Seaborn pairplot is a type of plot used to visualize the pairwise relationships between variables in a dataset. It creates a grid of scatterplots and histograms, where each variable in the dataset is plotted against every other variable. This allows you to quickly visualize how different variables are related to each other and to identify any patterns or trends in the data.</p> <p>The pairplot function in Seaborn allows you to specify various parameters, such as the data source, the variables to include, and the type of plot to use for the diagonal (e.g., a histogram or kernel density plot). It also allows you to add additional information to the plot, such as hue variables that can be used to group the data by a categorical variable.</p> <p>Overall, Seaborn pairplots are a useful tool for exploring and visualizing the relationships between variables in a dataset, and can help you to gain insights into the underlying patterns and trends in your data.</p> <pre><code>def seaborn_pairplot(self,args:dict):\n\n    num,cat = self.split_types(args['data'])\n\n    if(args['hue'] is not None):\n        hueloc = args['hue']\n        num = pd.concat([num,args['data'][args['hue']]],axis=1) \n        subgroups = len(args['data'][args['hue']].value_counts())\n        if(type(nlpi.pp['stheme']) is list):\n            palette = nlpi.pp['stheme'][:subgroups]\n        else:\n            palette = nlpi.pp['stheme']\n    else:\n        hueloc = None\n        palette = nlpi.pp['stheme']\n\n\n    sns.set_style(\"whitegrid\", {\n        \"ytick.major.size\": 0.1,\n        \"ytick.minor.size\": 0.05,\n        'grid.linestyle': '--'\n     })\n\n    sns.pairplot(num,\n                 hue=hueloc,\n                 corner=True,\n                 palette=palette,\n                 diag_kws={'linewidth':nlpi.pp['mew'],\n                           'fill':nlpi.pp['fill']},\n                 plot_kws={'edgecolor':nlpi.pp['mec'],\n                           'linewidth':nlpi.pp['mew'],\n                           'alpha':nlpi.pp['alpha'],\n                           's':nlpi.pp['s']})   \n\n    sns.despine(left=True, bottom=True)\n    plt.show()\n    nlpi.resetpp()\n</code></pre>"},{"location":"documentation/eda/meda_splot.html#slineplot","title":"<code>slineplot</code>description:code:","text":"<p>A Seaborn lineplot is a type of plot used to visualize the relationship between two continuous variables. It creates a line chart that displays the trend in the data over time or across some other continuous variable. Lineplots are useful for identifying trends and patterns in data, as well as for comparing the values of different variables over time or across different categories.</p> <p>The lineplot function in Seaborn allows you to specify various parameters, such as the data source, the variables to include, and the type of aggregation to use (e.g., mean, median, or sum). It also allows you to add additional information to the plot, such as hue variables that can be used to group the data by a categorical variable.</p> <p>Overall, Seaborn lineplots are a useful tool for exploring and visualizing the relationships between continuous variables in a dataset, and can help you to gain insights into the underlying patterns and trends in your data.</p> <pre><code>def seaborn_lineplot(self,args:dict):\n\n    if(args['hue'] is not None):\n        hueloc = args['data'][args['hue']]\n        if(type(nlpi.pp['stheme']) is str):\n            palette = nlpi.pp['stheme']\n        else:\n            palette = palette_rgb[:len(hueloc.value_counts())]\n\n    else:\n        hueloc = None\n        palette = palette_rgb\n\n    sns.set_style(\"whitegrid\", {\n        \"ytick.major.size\": 0.1,\n        \"ytick.minor.size\": 0.05,\n        'grid.linestyle': '--'\n     })\n\n    sns.lineplot(x=args['x'], \n                 y=args['y'],\n                 hue=args['hue'],\n                 alpha= nlpi.pp['alpha'],\n                 linewidth=nlpi.pp['mew'],\n                 data=args['data'],\n                 palette=palette)\n\n    sns.despine(left=True, bottom=True)\n    plt.show()\n    nlpi.resetpp()\n</code></pre>"},{"location":"documentation/eda/meda_splot.html#scorrplot","title":"<code>scorrplot</code>description:code:","text":"<p>A Seaborn heatmap is a graphical representation of data that uses color-coded cells to display values in a matrix. Heatmaps are commonly used to visualize the correlation between variables in a dataset, where each cell in the matrix represents the correlation coefficient between two variables. The color of the cell indicates the strength and direction of the correlation, with warmer colors (e.g., red) indicating positive correlations and cooler colors (e.g., blue) indicating negative correlations.</p> <p>Seaborn heatmaps can be customized with various parameters, such as the color palette, the axis labels, and the size and shape of the plot. They are useful for identifying patterns and trends in large datasets, and can help to highlight areas of high or low correlation between variables. Overall, Seaborn heatmaps are a powerful tool for exploring and visualizing complex data relationships in a clear and intuitive way.</p> <pre><code>def seaborn_heatmap(self,args:dict):\n\n    if(args['hue'] is not None):\n        hueloc = args['data'][args['hue']]\n        if(type(nlpi.pp['stheme']) is str):\n            palette = nlpi.pp['stheme']\n        else:\n            palette = palette_rgb[:len(hueloc.value_counts())]\n\n    else:\n        hueloc = None\n        palette = palette_rgb\n\n    num,_ = self.split_types(args['data'])\n    sns.heatmap(num,cmap=palette,\n                square=False,lw=2,\n                annot=True,cbar=True)    \n\n    plt.show()\n    nlpi.resetpp()\n</code></pre> <ol> <li> <p>Reference to the sub folder in <code>src</code> \u21a9</p> </li> <li> <p>Reference to the machine learning project phase identification defined here \u21a9</p> </li> <li> <p>location | github \u21a9</p> </li> <li> <p>location | github \u21a9</p> </li> </ol>"},{"location":"group/meetups.html","title":"Meetings","text":""},{"location":"group/meetups.html#group-meetings","title":"Group Meetings","text":"<p>Here's a collection of data from group meetups</p>"},{"location":"group/meetups.html#project-introduction","title":"\u276f\u276f project introduction","text":"<p> Slides</p> <p> Oct 15, 2023</p> <ul> <li>Discussion of project</li> <li>Project objectives</li> <li>mllibs internals</li> <li>What subtasks exist</li> <li>Distribution of roles</li> </ul> <p>Duration: 1 Hour</p>"},{"location":"group/meetups.html#individual-meetings","title":"Individual Meetings","text":"<p>A collections of all individual meetings</p>"},{"location":"group/members.html","title":"Members","text":""},{"location":"group/members.html#members","title":"Members","text":""},{"location":"group/status.html","title":"Task Status","text":"<p>In this section, we document the module feature registration</p>"},{"location":"group/status.html#available-tasks","title":"Available Tasks","text":"<p> User Recommendation System</p>"},{"location":"group/status.html#overview","title":"OVERVIEW:","text":"<p>Creation of recommendations to user during the project</p> Info Problem Statement:PurposedescriptionNecessity LevelVote <p>Currently there doesn't exist a mechanism that would allow a user to explore the functionality of the library content, nor are there mechanisms that would guide a user during the process doing a project. There is a need to develop an accurate and effective user recommendation system that that provide personal recommendations based on the user requests, as well as general trends/interactions that  </p> <p>The purpose of such functionality is to provide helpful suggestions, tips based on their preferences</p> <p>asafsfs </p> <p>3/5</p> <p>not available</p> <p> Module Function Label Classifier</p>"},{"location":"group/status.html#overview_1","title":"Overview","text":"<p>Creation of a classifier that would associate input text requests with module function labels </p> Problem Statement:PurposedescriptionNecessity LevelVote <p>In order for module functionality to be activated, there needs to be an inbuilt library functionality that would link an input user request to module functionality</p> <p>The purpose of such as classifier is to associated input text requests with module functions</p> <p>In order to implement such as a functionality, there is a need to create a </p> <p>5/5</p> <p>not available</p> <p> Module Function Label Generator</p>"},{"location":"group/status.html#overview_2","title":"Overview","text":"<p>Creation of a generator that would associate input text requests with module function labels </p> Problem Statement:PurposedescriptionAdvantagesLimitationsNecessity LevelVote <p>One of the issues associated with user request interpretation is the association of text to module functionality. In order for module functionality to be activated, there needs to be an inbuilt library mechanism that would link an input user requests to module functionality/functions. One of the ways to achieve this is via the NLP text generation problem. The outcome of the inplementation of such functionality should be that the </p> <p>The purpose of such as generator is to associated input text requests with module functions</p> <p>In order to implement such as a functionality, there is a need to create a </p> <p>One of the benefits of using such functionality, especially over the classification approach is its model capability to interpret user requests</p> <p>One of the limitations of such functionality is the speed at which the tokeniser &amp; models are loaded. If they are to be loaded from HuggingFace for each user session, this would force the user to wait before starting their project</p> <p>5/5</p> <p>not available</p>"},{"location":"group/status.html#task-allocation","title":"Task Allocation","text":""},{"location":"modules/adding.html","title":"Adding new modules","text":""},{"location":"modules/adding.html#overview","title":"Overview","text":"<p>To add a new module into <code>mllibs</code>, you need to add two components:</p> <ul> <li>A module <code>configuration</code> file, located in <code>/src/mllibs/corpus/</code> </li> <li>A module <code>components</code> file, located in <code>src/mllibs/</code></li> </ul> <p>The <code>configuration</code> file will hold text based information about each activation function in the module, whilst the <code>components</code> file will contain the relevant activation functions</p>"},{"location":"modules/adding.html#module-components-file","title":"Module Components File","text":"<p>Module activation functions are grouped together in a class format. Here is an example module, <code>sample</code>, which contains an activation function <code>function</code></p>"},{"location":"modules/adding.html#class-inheritance","title":"class inheritance","text":"<p>Modules can inherent any class, however as a minimum, it must always inherent the <code>nlpi</code> class</p>"},{"location":"modules/adding.html#activation-functions","title":"activation functions","text":"<p>Activation functions require only a single argument, <code>args:dict</code> aside from <code>self</code></p> <pre><code># sample module class structure\n\nclass Sample(nlpi):\n\n    '''\n\n    Initialise Module\n\n    '''\n    # called in nlpm\n\n    def __init__(self,nlp_config):\n        self.name = 'sample'             # unique module name identifier (used in nlpm/nlpi)\n        self.nlp_config = nlp_config  # text based info related to module (used in nlpm/nlpi)\n\n    '''\n\n    Function Selector \n\n    '''\n    # called in nlpi\n\n    def sel(self,args:dict):\n\n        self.select = args['pred_task']\n        self.args = args\n\n        if(self.select == 'function'):\n            self.function(self.args)\n\n    '''\n\n    Activation Functions\n\n    '''\n\n    def function(self,args:dict):\n        pass\n</code></pre>"},{"location":"modules/adding.html#module-configuration-file","title":"Module Configuration File","text":"<p>The <code>configuration</code> file contains information about the module (eg.<code>sample</code>) &amp; its stored functions <code>info</code>, as well as the <code>corpus</code> used in classificaiton of function labels <code>name</code></p> <pre><code>\"modules\": [\n\n{\n  \"name\": \"function\",\n\"corpus\": [\n          \"...\",\n          ],\n  \"info\": {\n          \"module\":\"sample\",\n          \"action\":\"...\",\n          \"topic\":\"...\",\n          \"subtopic\":\"...\",\n          \"input_format\":\"...\",\n          \"description\":\"...\",\n          \"output\":\"...\",\n          \"token_compat\":\"...\",\n          \"arg_compat\":\"...\"\n          }\n},\n\n...\n\n]\n</code></pre>"},{"location":"modules/adding.html#naming-conventions","title":"Naming Conventions","text":""},{"location":"modules/adding.html#activation-function-name","title":"Activation function name","text":"<p>Some important things to note:</p> <ul> <li>Module class name (eg.<code>Sample</code>) can be whatever you choose. The relevant class must then be used as import when grouping together all other modules. </li> <li>Module <code>configuration</code> must contain <code>name</code> (function names) that correspond to its relevant module </li> </ul>"},{"location":"modules/adding.html#file-names","title":"File names","text":"<p>Module <code>components</code> file names can be whatever you choose it to be. Module <code>configuration</code> file names as well can be anything you choose it to be, however its good practice to choose the same name for both module components so you don't loose track of which files belong together.</p>"},{"location":"modules/grouping.html","title":"Grouping modules","text":""},{"location":"modules/grouping.html#grouping-all-modules","title":"Grouping All Modules","text":""},{"location":"modules/list.html","title":"Available modules","text":""},{"location":"modules/list.html#available-modules","title":"Available Modules","text":""},{"location":"tutorials/overview.html","title":"hello","text":"","tags":["HTML5","JavaScript","CSS"]},{"location":"tutorials/overview.html#overview","title":"Overview","text":"<p>asfasf</p>","tags":["HTML5","JavaScript","CSS"]}]}